
import asyncio
import logging
import os
import re
import shutil
import tempfile
from pathlib import Path
from urllib.parse import urlparse

from telegram import Update
from telegram.constants import MessageEntityType
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters

import yt_dlp

# ------------ Settings ------------
# Telegram allows bot uploads up to ~2 GB. We'll try to stay below that.
MAX_TG_BYTES = int(os.getenv("MAX_TG_BYTES", str(1_900_000_000)))  # ~1.9 GB safety margin

# If NO_FFMPEG=1, we avoid formats that need merging and stick to progressive MP4 ≤480p.
NO_FFMPEG = os.getenv("NO_FFMPEG", "0") == "1"

# Default formats
FORMAT_WITH_FFMPEG = "bv*[ext=mp4][height<=720]+ba[ext=m4a]/b[ext=mp4][height<=720]/b[ext=mp4]/best"
FORMAT_NO_FFMPEG = "best[ext=mp4][height<=480]/best[height<=480]"
DEFAULT_FORMAT = FORMAT_NO_FFMPEG if NO_FFMPEG else FORMAT_WITH_FFMPEG

# Optional: Instagram session for private/protected posts (your own content).
IG_SESSIONID = os.getenv("IG_SESSIONID")  # e.g. "123456%3Aabcdef..."

# ----------------------------------

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
log = logging.getLogger("tg_video_bot")

URL_RE = re.compile(r"https?://\S+")

SUPPORTED_DOMAINS = (
    "youtube.com", "youtu.be", "m.youtube.com",
    "instagram.com", "instagr.am", "www.instagram.com",
    "tiktok.com", "vm.tiktok.com", "facebook.com", "fb.watch",
    "twitter.com", "x.com", "vimeo.com"
)


def is_supported_url(url: str) -> bool:
    try:
        host = urlparse(url).netloc.lower()
    except Exception:
        return False
    return any(host.endswith(d) for d in SUPPORTED_DOMAINS)


def find_urls(text: str) -> list[str]:
    return URL_RE.findall(text or "")


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    txt = [
        "<b>Hi!</b> Send me a link and I'll fetch the video for you.",
        "",
        "Supported: YouTube, Instagram, TikTok, Facebook, Twitter/X, Vimeo",
        f"Quality: {'≤480p (no-ffmpeg mode)' if NO_FFMPEG else '≤720p (ffmpeg mode)'}",
        "Tip: Use this only for content you own or have permission to download.",
    ]
    await update.effective_message.reply_html("\n".join(txt))


async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await start(update, context)


def _write_cookies_if_needed(tmp: Path) -> str | None:
    """
    If an IG session cookie is provided, write a minimal Netscape cookies.txt for yt-dlp.
    Returns path to the cookie file or None.
    """
    if not IG_SESSIONID:
        return None
    cookies_path = tmp / "cookies.txt"
    content = (
        "# Netscape HTTP Cookie File\n"
        "# This file was generated by tg_video_bot\n"
        ".instagram.com\tTRUE\t/\tTRUE\t2147483647\tsessionid\t" + IG_SESSIONID + "\n"
    )
    cookies_path.write_text(content, encoding="utf-8")
    return str(cookies_path)


def _pick_final_file(dirpath: Path) -> Path | None:
    """Pick the most likely final media file (prefer mp4)."""
    candidates = list(dirpath.glob("**/*"))
    media = [p for p in candidates if p.is_file() and p.suffix.lower() in (".mp4", ".mov", ".mkv", ".webm")]
    if not media:
        return None
    mp4s = [p for p in media if p.suffix.lower() == ".mp4"]
    pool = mp4s or media
    pool.sort(key=lambda p: (p.stat().st_size, p.stat().st_mtime), reverse=True)
    return pool[0]


def _make_ydl_opts(tmpdir: Path, fmt: str | None = None, cookiefile: str | None = None):
    ydl_opts = {
        "outtmpl": str(tmpdir / "%(title).80s-%(id)s.%(ext)s"),
        "noplaylist": True,
        "quiet": True,
        "nocheckcertificate": True,
        "retries": 3,
        "concurrent_fragment_downloads": 4,
        "merge_output_format": "mp4",
        "http_headers": {
            "User-Agent": (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/124.0 Safari/537.36"
            )
        },
        "progress_hooks": [],
    }

    if fmt:
        ydl_opts["format"] = fmt
    else:
        ydl_opts["format"] = DEFAULT_FORMAT

    # Only add ffmpeg postprocessor if we allow merging
    if not NO_FFMPEG:
        ydl_opts["postprocessors"] = [
            {"key": "FFmpegVideoConvertor", "preferedformat": "mp4"},
        ]

    if cookiefile:
        ydl_opts["cookiefile"] = cookiefile
    return ydl_opts


def _human(n: int) -> str:
    for unit in ("B", "KB", "MB", "GB", "TB"):
        if n < 1024:
            return f"{n:.0f} {unit}"
        n /= 1024
    return f"{n:.1f} PB"


def _is_probably_too_big(info: dict) -> bool:
    # Try to estimate if the chosen format will exceed Telegram limits
    size_keys = ("filesize", "filesize_approx")
    # Single format
    for k in size_keys:
        v = info.get(k)
        if isinstance(v, (int, float)) and v > MAX_TG_BYTES:
            return True

    # If merged formats are present
    total = 0
    if "requested_formats" in info and isinstance(info["requested_formats"], list):
        for f in info["requested_formats"]:
            for k in size_keys:
                v = f.get(k)
                if isinstance(v, (int, float)):
                    total += int(v)
        if total and total > MAX_TG_BYTES:
            return True
    return False


def _extract_and_download(url: str, tmpdir: Path, cookiefile: str | None = None) -> tuple[Path, str]:
    """
    Blocking helper to run inside a thread.
    Returns: (filepath, title)
    Raises: Exception on failure
    """
    # First pass: get info to check estimated size and title
    ydl_info_opts = _make_ydl_opts(tmpdir, fmt=DEFAULT_FORMAT, cookiefile=cookiefile)
    with yt_dlp.YoutubeDL(ydl_info_opts) as ydl:
        info = ydl.extract_info(url, download=False)
        title = info.get("title") or "video"
        if _is_probably_too_big(info):
            # Try lower resolution
            fallbacks = []
            if NO_FFMPEG:
                fallbacks = [
                    "best[ext=mp4][height<=360]/best[height<=360]",
                    "best[ext=mp4][height<=240]/best[height<=240]",
                ]
            else:
                fallbacks = [
                    "bv*[ext=mp4][height<=480]+ba[ext=m4a]/b[ext=mp4][height<=480]/b[ext=mp4]/best",
                    "bv*[ext=mp4][height<=360]+ba[ext=m4a]/b[ext=mp4][height<=360]/b[ext=mp4]/best",
                ]
            for fmt in fallbacks:
                ydl.params["format"] = fmt
                info2 = ydl.extract_info(url, download=False)
                if not _is_probably_too_big(info2):
                    info = info2
                    break
            else:
                raise RuntimeError(
                    "The video looks too large to send via Telegram after downscaling attempts."
                )

    # Second pass: do the actual download with the chosen (possibly adjusted) format
    ydl_dl_opts = _make_ydl_opts(tmpdir, fmt=ydl_info_opts["format"], cookiefile=cookiefile)
    with yt_dlp.YoutubeDL(ydl_dl_opts) as ydl:
        _ = ydl.extract_info(url, download=True)

    out_file = _pick_final_file(tmpdir)
    if not out_file or not out_file.exists():
        raise RuntimeError("Downloaded file not found (post-processing may have failed).")
    return out_file, title


async def _download_and_send(url: str, update: Update) -> None:
    msg = update.effective_message
    tmpdir = Path(tempfile.mkdtemp(prefix="dl_"))
    cookiefile = None
    try:
        if "instagram." in url and IG_SESSIONID:
            cookiefile = _write_cookies_if_needed(tmpdir)

        status = await msg.reply_text(f"⬇️ Downloading:\n{url}")
        filepath, title = await asyncio.to_thread(_extract_and_download, url, tmpdir, cookiefile)

        size = filepath.stat().st_size
        if size > MAX_TG_BYTES:
            await status.edit_text(
                f"⚠️ File is {_human(size)} which exceeds the configured max ({_human(MAX_TG_BYTES)}). "
                "Try a shorter video or lower resolution."
            )
            return

        await status.edit_text("📤 Uploading to Telegram…")
        await msg.reply_video(
            video=filepath.open("rb"),
            caption=f"{title}",
            supports_streaming=True,
        )
        await status.edit_text("✅ Done")
    except yt_dlp.utils.DownloadError as e:
        await msg.reply_text(f"❌ Download error:\n{e}")
    except Exception as e:
        await msg.reply_text(f"❌ Error: {e}")
    finally:
        try:
            shutil.rmtree(tmpdir, ignore_errors=True)
        except Exception:
            pass


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = update.effective_message.text or ""
    urls = [u for u in find_urls(text) if is_supported_url(u)]
    if not urls:
        await update.effective_message.reply_text("Please send a supported video link.")
        return
    for url in urls:
        await _download_and_send(url, update)


def main() -> None:
    token = os.getenv("BOT_TOKEN")
    if not token:
        raise SystemExit("BOT_TOKEN environment variable is required")
    app = Application.builder().token(token).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(
        MessageHandler(
            filters.TEXT & (filters.Entity(MessageEntityType.URL) | filters.Entity(MessageEntityType.TEXT_LINK) | filters.Regex(URL_RE)),
            handle_message,
        )
    )

    log.info("Bot is starting… (NO_FFMPEG=%s)", NO_FFMPEG)
    app.run_polling(drop_pending_updates=True)


if __name__ == "__main__":
    main()
